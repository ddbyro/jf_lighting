<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/__init__.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Home Assistant Integration&#10;&quot;&quot;&quot;&#10;&#10;import logging&#10;from homeassistant.core import HomeAssistant&#10;from homeassistant.helpers.typing import ConfigType&#10;from homeassistant.helpers.entity import Entity&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;DOMAIN = &quot;jellyfish_lighting&quot;&#10;&#10;async def async_setup(hass: HomeAssistant, config: ConfigType) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Set up the Jellyfish Lighting integration.&#10;    &quot;&quot;&quot;&#10;    # Placeholder for setup logic&#10;    _LOGGER.info(&quot;Setting up Jellyfish Lighting integration&quot;)&#10;    return True&#10;&#10;async def async_setup_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Store config entry data for platform setup.&#10;    &quot;&quot;&quot;&#10;    hass.data.setdefault(DOMAIN, {})[entry.entry_id] = entry.data&#10;    return True&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Home Assistant Integration&#10;&quot;&quot;&quot;&#10;&#10;import logging&#10;from homeassistant.core import HomeAssistant&#10;from homeassistant.helpers.typing import ConfigType&#10;from homeassistant.helpers.entity import Entity&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;DOMAIN = &quot;jellyfish_lighting&quot;&#10;&#10;async def async_setup(hass: HomeAssistant, config: ConfigType) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Set up the Jellyfish Lighting integration.&#10;    &quot;&quot;&quot;&#10;    # Placeholder for setup logic&#10;    _LOGGER.info(&quot;Setting up Jellyfish Lighting integration&quot;)&#10;    return True&#10;&#10;async def async_setup_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    try:&#10;        # Try to forward config entry to the light platform (modern HA)&#10;        forward = getattr(hass, &quot;async_forward_entry_setup&quot;, None)&#10;        if forward:&#10;            await forward(entry, &quot;light&quot;)&#10;        else:&#10;            # Fallback: store config entry data for platform setup&#10;            hass.data.setdefault(DOMAIN, {})[entry.entry_id] = entry.data&#10;        return True&#10;    except Exception as e:&#10;        _LOGGER.error(f&quot;Error setting up Jellyfish Lighting entry: {e}&quot;)&#10;        return False&#10;&#10;async def async_unload_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    unload = getattr(hass, &quot;async_forward_entry_unload&quot;, None)&#10;    if unload:&#10;        return await unload(entry, &quot;light&quot;)&#10;    hass.data[DOMAIN].pop(entry.entry_id, None)&#10;    return True" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/api.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting API Client&#10;&quot;&quot;&quot;&#10;import websocket&#10;import json&#10;import logging&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;class JellyfishLightingAPI:&#10;    def __init__(self, host: str, api_key: str = None):&#10;        self.host = host&#10;        self.api_key = api_key&#10;        self.ws_url = f&quot;ws://{host}:9000/ws&quot;&#10;&#10;    def _send_ws(self, payload):&#10;        try:&#10;            ws = websocket.WebSocket()&#10;            ws.connect(self.ws_url)&#10;            ws.send(json.dumps(payload))&#10;            resp = ws.recv()&#10;            ws.close()&#10;            return json.loads(resp)&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;WebSocket error: {e}&quot;)&#10;            return None&#10;&#10;    def get_state(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;ledPower&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        return resp[&quot;ledPower&quot;] if resp and &quot;ledPower&quot; in resp else None&#10;&#10;    def get_patterns(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;patternFileList&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        return resp[&quot;patternFileList&quot;] if resp and &quot;patternFileList&quot; in resp else []&#10;&#10;    def get_groups(self):&#10;        # Build a list of dicts with group name and id (if available)&#10;        patterns = self.get_patterns()&#10;        groups = {}&#10;        for pattern in patterns:&#10;            folder = pattern.get(&quot;folders&quot;)&#10;            if folder:&#10;                if folder not in groups:&#10;                    groups[folder] = {&quot;name&quot;: folder, &quot;patterns&quot;: []}&#10;                groups[folder][&quot;patterns&quot;].append(pattern[&quot;name&quot;])&#10;        # Log discovered groups for debugging&#10;        _LOGGER.info(f&quot;Discovered Jellyfish Lighting groups: {list(groups.values())}&quot;)&#10;        return list(groups.values())&#10;&#10;    def set_power(self, state: int, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: &quot;&quot;,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    def set_pattern(self, pattern_name, state=1, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: pattern_name,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    # Add more methods as needed for color/effect if supported by the controller&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting API Client&#10;&quot;&quot;&quot;&#10;import websocket&#10;import json&#10;import logging&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;class JellyfishLightingAPI:&#10;    def __init__(self, host: str, api_key: str = None):&#10;        self.host = host&#10;        self.api_key = api_key&#10;        self.ws_url = f&quot;ws://{host}:9000/ws&quot;&#10;&#10;    def _send_ws(self, payload):&#10;        try:&#10;            ws = websocket.WebSocket()&#10;            ws.connect(self.ws_url)&#10;            ws.send(json.dumps(payload))&#10;            resp = ws.recv()&#10;            ws.close()&#10;            return json.loads(resp)&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;WebSocket error: {e}&quot;)&#10;            return None&#10;&#10;    def get_state(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;ledPower&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        return resp[&quot;ledPower&quot;] if resp and &quot;ledPower&quot; in resp else None&#10;&#10;    def get_patterns(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;patternFileList&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        _LOGGER.info(f&quot;Full patternFileList response: {resp}&quot;)&#10;        return resp[&quot;patternFileList&quot;] if resp and &quot;patternFileList&quot; in resp else []&#10;&#10;    def get_groups(self):&#10;        # Build a list of dicts with group name and id (if available)&#10;        patterns = self.get_patterns()&#10;        groups = {}&#10;        for pattern in patterns:&#10;            folder = pattern.get(&quot;folders&quot;)&#10;            if folder:&#10;                if folder not in groups:&#10;                    groups[folder] = {&quot;name&quot;: folder, &quot;patterns&quot;: []}&#10;                groups[folder][&quot;patterns&quot;].append(pattern[&quot;name&quot;])&#10;        # Log discovered groups for debugging&#10;        _LOGGER.info(f&quot;Discovered Jellyfish Lighting groups: {list(groups.values())}&quot;)&#10;        return list(groups.values())&#10;&#10;    def set_power(self, state: int, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: &quot;&quot;,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    def set_pattern(self, pattern_name, state=1, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: pattern_name,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    # Add more methods as needed for color/effect if supported by the controller" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/config_flow.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/config_flow.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Config flow for Jellyfish Lighting integration&#10;&quot;&quot;&quot;&#10;import voluptuous as vol&#10;from homeassistant import config_entries&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .const import DOMAIN&#10;&#10;class JellyfishLightingConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):&#10;    VERSION = 1&#10;    async def async_step_user(self, user_input=None):&#10;        errors = {}&#10;        if user_input is not None:&#10;            # Optionally: Validate connection here&#10;            return self.async_create_entry(title=&quot;Jellyfish Lighting&quot;, data=user_input)&#10;        return self.async_show_form(&#10;            step_id=&quot;user&quot;,&#10;            data_schema=vol.Schema({&#10;                vol.Required(CONF_HOST): str,&#10;                vol.Optional(CONF_API_KEY): str,&#10;            }),&#10;            errors=errors,&#10;        )&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Config flow for Jellyfish Lighting integration&#10;&quot;&quot;&quot;&#10;import voluptuous as vol&#10;from homeassistant import config_entries&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .const import DOMAIN&#10;&#10;class JellyfishLightingConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):&#10;    VERSION = 1&#10;    async def async_step_user(self, user_input=None):&#10;        errors = {}&#10;        if user_input is not None:&#10;            # Optionally: Validate connection here&#10;            return self.async_create_entry(title=&quot;Jellyfish Lighting&quot;, data=user_input)&#10;        return self.async_show_form(&#10;            step_id=&quot;user&quot;,&#10;            data_schema=vol.Schema({&#10;                vol.Required(CONF_HOST): str,&#10;                vol.Optional(CONF_API_KEY): str,&#10;            }),&#10;            errors=errors,&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/const.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/const.py" />
              <option name="updatedContent" value="DOMAIN = &quot;jellyfish_lighting&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/light.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/light.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Light Entity for Home Assistant&#10;&quot;&quot;&quot;&#10;import logging&#10;from homeassistant.components.light import LightEntity, SUPPORT_COLOR, SUPPORT_EFFECT&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .api import JellyfishLightingAPI&#10;from .const import DOMAIN&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;async def async_setup_platform(hass, config, async_add_entities, discovery_info=None):&#10;    host = config.get(CONF_HOST)&#10;    api_key = config.get(CONF_API_KEY)&#10;    api = JellyfishLightingAPI(host, api_key)&#10;    async_add_entities([JellyfishLight(api)])&#10;&#10;class JellyfishLighting:&#10;    def __init__(self, host, api_key=None):&#10;        self.api = JellyfishLightingAPI(host, api_key)&#10;&#10;    def get_groups(self):&#10;        # Use synchronous call since websocket-client is blocking&#10;        return self.api.get_groups()&#10;&#10;    def close(self):&#10;        pass  # No persistent connection to close&#10;&#10;async def async_setup_entry(hass, entry, async_add_entities):&#10;    entry_data = hass.data[DOMAIN][entry.entry_id] if DOMAIN in hass.data and entry.entry_id in hass.data[DOMAIN] else entry.data&#10;    host = entry_data.get(&quot;host&quot;)&#10;    api_key = entry_data.get(&quot;api_key&quot;)&#10;    lighting = JellyfishLighting(host, api_key)&#10;    groups = lighting.get_groups()&#10;    entities = []&#10;    if groups:&#10;        for group in groups:&#10;            entities.append(JellyfishLight(lighting.api, group))&#10;    else:&#10;        entities.append(JellyfishLight(lighting.api, None))&#10;    async_add_entities(entities)&#10;&#10;class JellyfishLight(LightEntity):&#10;    def __init__(self, api: JellyfishLightingAPI, group: str = None):&#10;        self._api = api&#10;        self._group = group&#10;        self._is_on = False&#10;        self._rgb_color = (255, 255, 255)&#10;        self._effect = None&#10;        self._available_effects = []&#10;        self._name = group if group else &quot;Jellyfish Lighting&quot;&#10;        self._group_id = group if group else None&#10;&#10;    async def async_added_to_hass(self):&#10;        await self.async_update()&#10;&#10;    @property&#10;    def name(self):&#10;        return self._name&#10;&#10;    @property&#10;    def unique_id(self):&#10;        return f&quot;jellyfish_{self._group_id}&quot; if self._group_id else None&#10;&#10;    @property&#10;    def is_on(self):&#10;        return self._is_on&#10;&#10;    @property&#10;    def rgb_color(self):&#10;        return self._rgb_color&#10;&#10;    @property&#10;    def effect_list(self):&#10;        return self._available_effects&#10;&#10;    @property&#10;    def effect(self):&#10;        return self._effect&#10;&#10;    @property&#10;    def supported_features(self):&#10;        return SUPPORT_COLOR | SUPPORT_EFFECT&#10;&#10;    async def async_turn_on(self, **kwargs):&#10;        try:&#10;            state = 1&#10;            zone_name = self._group_id&#10;            if &quot;effect&quot; in kwargs:&#10;                pattern = kwargs[&quot;effect&quot;]&#10;                self._api.set_pattern(pattern, state, zone_name)&#10;                self._effect = pattern&#10;            else:&#10;                self._api.set_power(state, zone_name)&#10;            self._is_on = True&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning on Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_turn_off(self, **kwargs):&#10;        try:&#10;            state = 0&#10;            zone_name = self._group_id&#10;            self._api.set_power(state, zone_name)&#10;            self._is_on = False&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning off Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_update(self):&#10;        try:&#10;            zone_name = self._group_id&#10;            power = self._api.get_state()&#10;            self._is_on = power == True&#10;            patterns = self._api.get_patterns()&#10;            self._available_effects = [p[&quot;name&quot;] for p in patterns if p.get(&quot;folders&quot;) == zone_name] if zone_name else [p[&quot;name&quot;] for p in patterns]&#10;            # No direct color support in API, so leave as last set&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error updating Jellyfish Lighting: {e}&quot;)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Light Entity for Home Assistant&#10;&quot;&quot;&quot;&#10;import logging&#10;from homeassistant.components.light import LightEntity, SUPPORT_COLOR, SUPPORT_EFFECT&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .api import JellyfishLightingAPI&#10;from .const import DOMAIN&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;async def async_setup_platform(hass, config, async_add_entities, discovery_info=None):&#10;    host = config.get(CONF_HOST)&#10;    api_key = config.get(CONF_API_KEY)&#10;    api = JellyfishLightingAPI(host, api_key)&#10;    async_add_entities([JellyfishLight(api)])&#10;&#10;class JellyfishLighting:&#10;    def __init__(self, host, api_key=None):&#10;        self.api = JellyfishLightingAPI(host, api_key)&#10;&#10;    def get_groups(self):&#10;        # Use synchronous call since websocket-client is blocking&#10;        return self.api.get_groups()&#10;&#10;    def close(self):&#10;        pass  # No persistent connection to close&#10;&#10;async def async_setup_entry(hass, entry, async_add_entities):&#10;    entry_data = hass.data[DOMAIN][entry.entry_id] if DOMAIN in hass.data and entry.entry_id in hass.data[DOMAIN] else entry.data&#10;    host = entry_data.get(&quot;host&quot;)&#10;    api_key = entry_data.get(&quot;api_key&quot;)&#10;    lighting = JellyfishLighting(host, api_key)&#10;    groups = lighting.get_groups()&#10;    entities = []&#10;    if groups:&#10;        for group in groups:&#10;            entities.append(JellyfishLight(lighting.api, group))&#10;    else:&#10;        entities.append(JellyfishLight(lighting.api, None))&#10;    async_add_entities(entities)&#10;&#10;class JellyfishLight(LightEntity):&#10;    def __init__(self, api: JellyfishLightingAPI, group: dict = None):&#10;        self._api = api&#10;        self._group = group&#10;        self._is_on = False&#10;        self._rgb_color = (255, 255, 255)&#10;        self._effect = None&#10;        self._available_effects = group[&quot;patterns&quot;] if group else []&#10;        self._name = group[&quot;name&quot;] if group else &quot;Jellyfish Lighting&quot;&#10;        self._group_id = group[&quot;name&quot;] if group else None&#10;&#10;    async def async_added_to_hass(self):&#10;        await self.async_update()&#10;&#10;    @property&#10;    def name(self):&#10;        return self._name&#10;&#10;    @property&#10;    def unique_id(self):&#10;        return f&quot;jellyfish_{self._group_id}&quot; if self._group_id else None&#10;&#10;    @property&#10;    def is_on(self):&#10;        return self._is_on&#10;&#10;    @property&#10;    def rgb_color(self):&#10;        return self._rgb_color&#10;&#10;    @property&#10;    def effect_list(self):&#10;        return self._available_effects&#10;&#10;    @property&#10;    def effect(self):&#10;        return self._effect&#10;&#10;    @property&#10;    def supported_features(self):&#10;        return SUPPORT_COLOR | SUPPORT_EFFECT&#10;&#10;    async def async_turn_on(self, **kwargs):&#10;        try:&#10;            state = 1&#10;            zone_name = self._group_id&#10;            if &quot;effect&quot; in kwargs:&#10;                pattern = kwargs[&quot;effect&quot;]&#10;                self._api.set_pattern(pattern, state, zone_name)&#10;                self._effect = pattern&#10;            else:&#10;                self._api.set_power(state, zone_name)&#10;            self._is_on = True&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning on Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_turn_off(self, **kwargs):&#10;        try:&#10;            state = 0&#10;            zone_name = self._group_id&#10;            self._api.set_power(state, zone_name)&#10;            self._is_on = False&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning off Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_update(self):&#10;        try:&#10;            zone_name = self._group_id&#10;            power = self._api.get_state()&#10;            self._is_on = power == True&#10;            # Only show patterns for this group&#10;            if self._group:&#10;                self._available_effects = self._group[&quot;patterns&quot;]&#10;            else:&#10;                patterns = self._api.get_patterns()&#10;                self._available_effects = [p[&quot;name&quot;] for p in patterns]&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error updating Jellyfish Lighting: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/manifest.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/manifest.json" />
              <option name="originalContent" value="{&#10;  &quot;domain&quot;: &quot;jellyfish_lighting&quot;,&#10;  &quot;name&quot;: &quot;Jellyfish Lighting&quot;,&#10;  &quot;documentation&quot;: &quot;https://github.com/parkerjfl/JellyfishLightingAPIExplorer/blob/main/Jellyfish%20Lighting%20API%20Documentation%20(1).pdf&quot;,&#10;  &quot;requirements&quot;: [],&#10;  &quot;dependencies&quot;: [],&#10;  &quot;codeowners&quot;: [&quot;@your-github-username&quot;],&#10;  &quot;config_flow&quot;: true,&#10;  &quot;version&quot;: &quot;0.1.0&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;domain&quot;: &quot;jellyfish_lighting&quot;,&#10;  &quot;name&quot;: &quot;Jellyfish Lighting&quot;,&#10;  &quot;documentation&quot;: &quot;https://github.com/parkerjfl/JellyfishLightingAPIExplorer/blob/main/Jellyfish%20Lighting%20API%20Documentation%20(1).pdf&quot;,&#10;  &quot;requirements&quot;: [],&#10;  &quot;dependencies&quot;: [],&#10;  &quot;codeowners&quot;: [&quot;@your-github-username&quot;],&#10;  &quot;config_flow&quot;: true,&#10;  &quot;version&quot;: &quot;0.1.0&quot;,&#10;  &quot;platforms&quot;: [&quot;light&quot;]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>