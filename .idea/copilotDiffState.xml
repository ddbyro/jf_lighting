<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/__init__.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Home Assistant Integration&#10;&quot;&quot;&quot;&#10;&#10;import logging&#10;from homeassistant.core import HomeAssistant&#10;from homeassistant.helpers.typing import ConfigType&#10;from homeassistant.helpers.entity import Entity&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;DOMAIN = &quot;jellyfish_lighting&quot;&#10;&#10;async def async_setup(hass: HomeAssistant, config: ConfigType) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Set up the Jellyfish Lighting integration.&#10;    &quot;&quot;&quot;&#10;    # Placeholder for setup logic&#10;    _LOGGER.info(&quot;Setting up Jellyfish Lighting integration&quot;)&#10;    return True&#10;&#10;async def async_setup_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Store config entry data for platform setup.&#10;    &quot;&quot;&quot;&#10;    hass.data.setdefault(DOMAIN, {})[entry.entry_id] = entry.data&#10;    return True&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Home Assistant Integration&#10;&quot;&quot;&quot;&#10;&#10;import logging&#10;from homeassistant.core import HomeAssistant&#10;from homeassistant.helpers.typing import ConfigType&#10;from homeassistant.helpers.entity import Entity&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;DOMAIN = &quot;jellyfish_lighting&quot;&#10;&#10;async def async_setup(hass: HomeAssistant, config: ConfigType) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Set up the Jellyfish Lighting integration.&#10;    &quot;&quot;&quot;&#10;    # Placeholder for setup logic&#10;    _LOGGER.info(&quot;Setting up Jellyfish Lighting integration&quot;)&#10;    return True&#10;&#10;async def async_setup_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    try:&#10;        # Try to forward config entry to the light platform (modern HA)&#10;        forward = getattr(hass, &quot;async_forward_entry_setup&quot;, None)&#10;        if forward:&#10;            await forward(entry, &quot;light&quot;)&#10;        else:&#10;            # Fallback: store config entry data for platform setup&#10;            hass.data.setdefault(DOMAIN, {})[entry.entry_id] = entry.data&#10;        return True&#10;    except Exception as e:&#10;        _LOGGER.error(f&quot;Error setting up Jellyfish Lighting entry: {e}&quot;)&#10;        return False&#10;&#10;async def async_unload_entry(hass: HomeAssistant, entry) -&gt; bool:&#10;    unload = getattr(hass, &quot;async_forward_entry_unload&quot;, None)&#10;    if unload:&#10;        return await unload(entry, &quot;light&quot;)&#10;    hass.data[DOMAIN].pop(entry.entry_id, None)&#10;    return True" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/api.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting API Client&#10;&quot;&quot;&quot;&#10;import aiohttp&#10;import logging&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;class JellyfishLightingAPI:&#10;    def __init__(self, host: str, api_key: str = None):&#10;        self.host = host&#10;        self.api_key = api_key&#10;        self.base_url = f&quot;http://{host}/api&quot;&#10;        self.session = aiohttp.ClientSession()&#10;&#10;    async def _request(self, method, endpoint, **kwargs):&#10;        url = f&quot;{self.base_url}/{endpoint}&quot;&#10;        headers = {}&#10;        if self.api_key:&#10;            headers[&quot;Authorization&quot;] = f&quot;Bearer {self.api_key}&quot;&#10;        try:&#10;            async with self.session.request(method, url, headers=headers, **kwargs) as resp:&#10;                resp.raise_for_status()&#10;                return await resp.json()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;API request error: {e}&quot;)&#10;            return None&#10;&#10;    async def get_status(self):&#10;        return await self._request(&quot;GET&quot;, &quot;status&quot;)&#10;&#10;    async def set_power(self, on: bool):&#10;        return await self._request(&quot;POST&quot;, &quot;power&quot;, json={&quot;on&quot;: on})&#10;&#10;    async def set_color(self, r: int, g: int, b: int):&#10;        return await self._request(&quot;POST&quot;, &quot;color&quot;, json={&quot;r&quot;: r, &quot;g&quot;: g, &quot;b&quot;: b})&#10;&#10;    async def set_effect(self, effect_name: str, params: dict = None):&#10;        data = {&quot;effect&quot;: effect_name}&#10;        if params:&#10;            data.update(params)&#10;        return await self._request(&quot;POST&quot;, &quot;effect&quot;, json=data)&#10;&#10;    async def get_effects(self):&#10;        return await self._request(&quot;GET&quot;, &quot;effects&quot;)&#10;&#10;    async def get_groups(self):&#10;        return await self._request(&quot;GET&quot;, &quot;groups&quot;)&#10;&#10;    async def get_group_status(self, group_id):&#10;        return await self._request(&quot;GET&quot;, f&quot;groups/{group_id}/status&quot;)&#10;&#10;    async def set_group_power(self, group_id, on: bool):&#10;        return await self._request(&quot;POST&quot;, f&quot;groups/{group_id}/power&quot;, json={&quot;on&quot;: on})&#10;&#10;    async def set_group_color(self, group_id, r: int, g: int, b: int):&#10;        return await self._request(&quot;POST&quot;, f&quot;groups/{group_id}/color&quot;, json={&quot;r&quot;: r, &quot;g&quot;: g, &quot;b&quot;: b})&#10;&#10;    async def set_group_effect(self, group_id, effect_name: str, params: dict = None):&#10;        data = {&quot;effect&quot;: effect_name}&#10;        if params:&#10;            data.update(params)&#10;        return await self._request(&quot;POST&quot;, f&quot;groups/{group_id}/effect&quot;, json=data)&#10;&#10;    async def get_group_effects(self, group_id):&#10;        return await self._request(&quot;GET&quot;, f&quot;groups/{group_id}/effects&quot;)&#10;&#10;    async def close(self):&#10;        await self.session.close()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting API Client&#10;&quot;&quot;&quot;&#10;import websocket&#10;import json&#10;import logging&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;class JellyfishLightingAPI:&#10;    def __init__(self, host: str, api_key: str = None):&#10;        self.host = host&#10;        self.api_key = api_key&#10;        self.ws_url = f&quot;ws://{host}:9000/ws&quot;&#10;&#10;    def _send_ws(self, payload):&#10;        try:&#10;            ws = websocket.WebSocket()&#10;            ws.connect(self.ws_url)&#10;            ws.send(json.dumps(payload))&#10;            resp = ws.recv()&#10;            ws.close()&#10;            return json.loads(resp)&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;WebSocket error: {e}&quot;)&#10;            return None&#10;&#10;    def get_state(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;ledPower&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        return resp[&quot;ledPower&quot;] if resp and &quot;ledPower&quot; in resp else None&#10;&#10;    def get_patterns(self):&#10;        payload = {&quot;cmd&quot;: &quot;toCtlrGet&quot;, &quot;get&quot;: [[&quot;patternFileList&quot;]]}&#10;        resp = self._send_ws(payload)&#10;        return resp[&quot;patternFileList&quot;] if resp and &quot;patternFileList&quot; in resp else []&#10;&#10;    def get_groups(self):&#10;        # Groups/zones are typically in the config or pattern response&#10;        patterns = self.get_patterns()&#10;        groups = set()&#10;        for pattern in patterns:&#10;            if &quot;folders&quot; in pattern:&#10;                groups.add(pattern[&quot;folders&quot;])&#10;        return list(groups)&#10;&#10;    def set_power(self, state: int, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: &quot;&quot;,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    def set_pattern(self, pattern_name, state=1, zone_name=None):&#10;        payload = {&#10;            &quot;cmd&quot;: &quot;toCtlrSet&quot;,&#10;            &quot;runPattern&quot;: {&#10;                &quot;file&quot;: pattern_name,&#10;                &quot;data&quot;: &quot;&quot;,&#10;                &quot;id&quot;: zone_name if zone_name else &quot;Zone&quot;,&#10;                &quot;state&quot;: state,&#10;                &quot;zoneName&quot;: [zone_name] if zone_name else [&quot;Zone&quot;]&#10;            }&#10;        }&#10;        return self._send_ws(payload)&#10;&#10;    # Add more methods as needed for color/effect if supported by the controller" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/config_flow.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/config_flow.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Config flow for Jellyfish Lighting integration&#10;&quot;&quot;&quot;&#10;import voluptuous as vol&#10;from homeassistant import config_entries&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .const import DOMAIN&#10;&#10;class JellyfishLightingConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):&#10;    VERSION = 1&#10;    async def async_step_user(self, user_input=None):&#10;        errors = {}&#10;        if user_input is not None:&#10;            # Optionally: Validate connection here&#10;            return self.async_create_entry(title=&quot;Jellyfish Lighting&quot;, data=user_input)&#10;        return self.async_show_form(&#10;            step_id=&quot;user&quot;,&#10;            data_schema=vol.Schema({&#10;                vol.Required(CONF_HOST): str,&#10;                vol.Optional(CONF_API_KEY): str,&#10;            }),&#10;            errors=errors,&#10;        )&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Config flow for Jellyfish Lighting integration&#10;&quot;&quot;&quot;&#10;import voluptuous as vol&#10;from homeassistant import config_entries&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .const import DOMAIN&#10;&#10;class JellyfishLightingConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):&#10;    VERSION = 1&#10;    async def async_step_user(self, user_input=None):&#10;        errors = {}&#10;        if user_input is not None:&#10;            # Optionally: Validate connection here&#10;            return self.async_create_entry(title=&quot;Jellyfish Lighting&quot;, data=user_input)&#10;        return self.async_show_form(&#10;            step_id=&quot;user&quot;,&#10;            data_schema=vol.Schema({&#10;                vol.Required(CONF_HOST): str,&#10;                vol.Optional(CONF_API_KEY): str,&#10;            }),&#10;            errors=errors,&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/const.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/const.py" />
              <option name="updatedContent" value="DOMAIN = &quot;jellyfish_lighting&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/light.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/light.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Light Entity for Home Assistant&#10;&quot;&quot;&quot;&#10;import logging&#10;from homeassistant.components.light import LightEntity, SUPPORT_COLOR, SUPPORT_EFFECT&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .api import JellyfishLightingAPI&#10;from .const import DOMAIN&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;async def async_setup_platform(hass, config, async_add_entities, discovery_info=None):&#10;    host = config.get(CONF_HOST)&#10;    api_key = config.get(CONF_API_KEY)&#10;    api = JellyfishLightingAPI(host, api_key)&#10;    async_add_entities([JellyfishLight(api)])&#10;&#10;class JellyfishLighting:&#10;    def __init__(self, host, api_key=None):&#10;        self.api = JellyfishLightingAPI(host, api_key)&#10;&#10;    async def get_groups(self):&#10;        try:&#10;            groups_resp = await self.api.get_groups()&#10;            return groups_resp.get(&quot;groups&quot;, []) if groups_resp else []&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error fetching Jellyfish Lighting groups: {e}&quot;)&#10;            return []&#10;&#10;    async def close(self):&#10;        await self.api.close()&#10;&#10;async def async_setup_entry(hass, entry, async_add_entities):&#10;    entry_data = hass.data[DOMAIN][entry.entry_id] if DOMAIN in hass.data and entry.entry_id in hass.data[DOMAIN] else entry.data&#10;    host = entry_data.get(&quot;host&quot;)&#10;    api_key = entry_data.get(&quot;api_key&quot;)&#10;    lighting = JellyfishLighting(host, api_key)&#10;    groups = await lighting.get_groups()&#10;    entities = []&#10;    if groups:&#10;        for group in groups:&#10;            entities.append(JellyfishLight(lighting.api, group))&#10;    else:&#10;        entities.append(JellyfishLight(lighting.api, None))&#10;    async_add_entities(entities)&#10;&#10;class JellyfishLight(LightEntity):&#10;    def __init__(self, api: JellyfishLightingAPI, group: dict = None):&#10;        self._api = api&#10;        self._group = group&#10;        self._is_on = False&#10;        self._rgb_color = (255, 255, 255)&#10;        self._effect = None&#10;        self._available_effects = []&#10;        self._name = group[&quot;name&quot;] if group else &quot;Jellyfish Lighting&quot;&#10;        self._group_id = group[&quot;id&quot;] if group and &quot;id&quot; in group else None&#10;&#10;    async def async_added_to_hass(self):&#10;        await self.async_update()&#10;&#10;    @property&#10;    def name(self):&#10;        return self._name&#10;&#10;    @property&#10;    def unique_id(self):&#10;        return f&quot;jellyfish_{self._group_id}&quot; if self._group_id else None&#10;&#10;    @property&#10;    def is_on(self):&#10;        return self._is_on&#10;&#10;    @property&#10;    def rgb_color(self):&#10;        return self._rgb_color&#10;&#10;    @property&#10;    def effect_list(self):&#10;        return self._available_effects&#10;&#10;    @property&#10;    def effect(self):&#10;        return self._effect&#10;&#10;    @property&#10;    def supported_features(self):&#10;        return SUPPORT_COLOR | SUPPORT_EFFECT&#10;&#10;    async def async_turn_on(self, **kwargs):&#10;        try:&#10;            if self._group_id:&#10;                if &quot;rgb_color&quot; in kwargs:&#10;                    r, g, b = kwargs[&quot;rgb_color&quot;]&#10;                    await self._api.set_group_color(self._group_id, r, g, b)&#10;                    self._rgb_color = (r, g, b)&#10;                if &quot;effect&quot; in kwargs:&#10;                    await self._api.set_group_effect(self._group_id, kwargs[&quot;effect&quot;])&#10;                    self._effect = kwargs[&quot;effect&quot;]&#10;                await self._api.set_group_power(self._group_id, True)&#10;            else:&#10;                if &quot;rgb_color&quot; in kwargs:&#10;                    r, g, b = kwargs[&quot;rgb_color&quot;]&#10;                    await self._api.set_color(r, g, b)&#10;                    self._rgb_color = (r, g, b)&#10;                if &quot;effect&quot; in kwargs:&#10;                    await self._api.set_effect(kwargs[&quot;effect&quot;])&#10;                    self._effect = kwargs[&quot;effect&quot;]&#10;                await self._api.set_power(True)&#10;            self._is_on = True&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning on Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_turn_off(self, **kwargs):&#10;        try:&#10;            if self._group_id:&#10;                await self._api.set_group_power(self._group_id, False)&#10;            else:&#10;                await self._api.set_power(False)&#10;            self._is_on = False&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning off Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_update(self):&#10;        try:&#10;            if self._group_id:&#10;                status = await self._api.get_group_status(self._group_id)&#10;                effects = await self._api.get_group_effects(self._group_id)&#10;            else:&#10;                status = await self._api.get_status()&#10;                effects = await self._api.get_effects()&#10;            if status:&#10;                self._is_on = status.get(&quot;on&quot;, self._is_on)&#10;                color = status.get(&quot;color&quot;, {})&#10;                self._rgb_color = (&#10;                    color.get(&quot;r&quot;, 255),&#10;                    color.get(&quot;g&quot;, 255),&#10;                    color.get(&quot;b&quot;, 255)&#10;                )&#10;                self._effect = status.get(&quot;effect&quot;, self._effect)&#10;            if effects:&#10;                self._available_effects = effects.get(&quot;effects&quot;, [])&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error updating Jellyfish Lighting: {e}&quot;)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Jellyfish Lighting Light Entity for Home Assistant&#10;&quot;&quot;&quot;&#10;import logging&#10;from homeassistant.components.light import LightEntity, SUPPORT_COLOR, SUPPORT_EFFECT&#10;from homeassistant.const import CONF_HOST, CONF_API_KEY&#10;from .api import JellyfishLightingAPI&#10;from .const import DOMAIN&#10;&#10;_LOGGER = logging.getLogger(__name__)&#10;&#10;async def async_setup_platform(hass, config, async_add_entities, discovery_info=None):&#10;    host = config.get(CONF_HOST)&#10;    api_key = config.get(CONF_API_KEY)&#10;    api = JellyfishLightingAPI(host, api_key)&#10;    async_add_entities([JellyfishLight(api)])&#10;&#10;class JellyfishLighting:&#10;    def __init__(self, host, api_key=None):&#10;        self.api = JellyfishLightingAPI(host, api_key)&#10;&#10;    def get_groups(self):&#10;        # Use synchronous call since websocket-client is blocking&#10;        return self.api.get_groups()&#10;&#10;    def close(self):&#10;        pass  # No persistent connection to close&#10;&#10;async def async_setup_entry(hass, entry, async_add_entities):&#10;    entry_data = hass.data[DOMAIN][entry.entry_id] if DOMAIN in hass.data and entry.entry_id in hass.data[DOMAIN] else entry.data&#10;    host = entry_data.get(&quot;host&quot;)&#10;    api_key = entry_data.get(&quot;api_key&quot;)&#10;    lighting = JellyfishLighting(host, api_key)&#10;    groups = lighting.get_groups()&#10;    entities = []&#10;    if groups:&#10;        for group in groups:&#10;            entities.append(JellyfishLight(lighting.api, group))&#10;    else:&#10;        entities.append(JellyfishLight(lighting.api, None))&#10;    async_add_entities(entities)&#10;&#10;class JellyfishLight(LightEntity):&#10;    def __init__(self, api: JellyfishLightingAPI, group: str = None):&#10;        self._api = api&#10;        self._group = group&#10;        self._is_on = False&#10;        self._rgb_color = (255, 255, 255)&#10;        self._effect = None&#10;        self._available_effects = []&#10;        self._name = group if group else &quot;Jellyfish Lighting&quot;&#10;        self._group_id = group if group else None&#10;&#10;    async def async_added_to_hass(self):&#10;        await self.async_update()&#10;&#10;    @property&#10;    def name(self):&#10;        return self._name&#10;&#10;    @property&#10;    def unique_id(self):&#10;        return f&quot;jellyfish_{self._group_id}&quot; if self._group_id else None&#10;&#10;    @property&#10;    def is_on(self):&#10;        return self._is_on&#10;&#10;    @property&#10;    def rgb_color(self):&#10;        return self._rgb_color&#10;&#10;    @property&#10;    def effect_list(self):&#10;        return self._available_effects&#10;&#10;    @property&#10;    def effect(self):&#10;        return self._effect&#10;&#10;    @property&#10;    def supported_features(self):&#10;        return SUPPORT_COLOR | SUPPORT_EFFECT&#10;&#10;    async def async_turn_on(self, **kwargs):&#10;        try:&#10;            state = 1&#10;            zone_name = self._group_id&#10;            if &quot;effect&quot; in kwargs:&#10;                pattern = kwargs[&quot;effect&quot;]&#10;                self._api.set_pattern(pattern, state, zone_name)&#10;                self._effect = pattern&#10;            else:&#10;                self._api.set_power(state, zone_name)&#10;            self._is_on = True&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning on Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_turn_off(self, **kwargs):&#10;        try:&#10;            state = 0&#10;            zone_name = self._group_id&#10;            self._api.set_power(state, zone_name)&#10;            self._is_on = False&#10;            await self.async_update()&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error turning off Jellyfish Lighting: {e}&quot;)&#10;&#10;    async def async_update(self):&#10;        try:&#10;            zone_name = self._group_id&#10;            power = self._api.get_state()&#10;            self._is_on = power == True&#10;            patterns = self._api.get_patterns()&#10;            self._available_effects = [p[&quot;name&quot;] for p in patterns if p.get(&quot;folders&quot;) == zone_name] if zone_name else [p[&quot;name&quot;] for p in patterns]&#10;            # No direct color support in API, so leave as last set&#10;        except Exception as e:&#10;            _LOGGER.error(f&quot;Error updating Jellyfish Lighting: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_components/jellyfish_lighting/manifest.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_components/jellyfish_lighting/manifest.json" />
              <option name="originalContent" value="{&#10;  &quot;domain&quot;: &quot;jellyfish_lighting&quot;,&#10;  &quot;name&quot;: &quot;Jellyfish Lighting&quot;,&#10;  &quot;documentation&quot;: &quot;https://github.com/parkerjfl/JellyfishLightingAPIExplorer/blob/main/Jellyfish%20Lighting%20API%20Documentation%20(1).pdf&quot;,&#10;  &quot;requirements&quot;: [],&#10;  &quot;dependencies&quot;: [],&#10;  &quot;codeowners&quot;: [&quot;@your-github-username&quot;],&#10;  &quot;config_flow&quot;: true,&#10;  &quot;version&quot;: &quot;0.1.0&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;domain&quot;: &quot;jellyfish_lighting&quot;,&#10;  &quot;name&quot;: &quot;Jellyfish Lighting&quot;,&#10;  &quot;documentation&quot;: &quot;https://github.com/parkerjfl/JellyfishLightingAPIExplorer/blob/main/Jellyfish%20Lighting%20API%20Documentation%20(1).pdf&quot;,&#10;  &quot;requirements&quot;: [],&#10;  &quot;dependencies&quot;: [],&#10;  &quot;codeowners&quot;: [&quot;@your-github-username&quot;],&#10;  &quot;config_flow&quot;: true,&#10;  &quot;version&quot;: &quot;0.1.0&quot;,&#10;  &quot;platforms&quot;: [&quot;light&quot;]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>